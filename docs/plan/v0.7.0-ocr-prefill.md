# Plan: v0.7.0 — OCR pre-fill

## Goal

After the user takes a label photo on the add-wine form, run on-device OCR to
pre-fill producer, name, and vintage. Save the raw OCR output plus the
user-corrected field values to `data/ocr-training.json` in the GitHub repo as
training data for a future model.

---

## Technology choice: Tesseract.js

**Tesseract.js v5** (Apache 2.0 licence) runs entirely in the browser via WASM
Workers. It returns per-word text, confidence scores, and bounding boxes — exactly
the structure needed for training data.

Alternatives considered:
- Vision-language models (SmolVLM, Florence-2 via Transformers.js): more capable,
  but model weights are 500 MB+, unsuitable for a mobile PWA
- Cloud OCR API: requires internet, adds latency, has cost, breaks offline-first

Tesseract.js downloads the English language data (~4 MB) from CDN on first use and
caches it in the browser. Subsequent uses work offline.

**Known risk:** Tesseract.js uses module workers. As with `@jsquash/avif`, these
may not resolve correctly in Vite dev over local network. OCR will be tested over
HTTPS (GitHub Pages deploy or a self-signed cert). If dev is broken, a `--https`
flag or test via deployed app is the workaround — no code changes needed.

---

## OCR pre-fill heuristics

The OCR text is used to seed fields; the user always reviews before submitting.

- **vintage**: first 4-digit integer in range 1800–2100 found in the text
- **producer**: first non-empty line of OCR text
- **name**: second non-empty line of OCR text

These are intentionally simple. Pre-fill value is better than nothing; the user
corrects what's wrong. The corrected values are the training signal.

---

## Training data format (`data/ocr-training.json`)

Stored alongside `data/cellar.json` in the GitHub repo. Not part of the wine
schema — a separate file.

```json
{
  "version": 1,
  "entries": [
    {
      "wineId": "uuid-of-wine-entry",
      "capturedAt": "2026-02-20T18:00:00.000Z",
      "ocr": {
        "text": "Weingut Keller\nRiesling Trocken\n2021",
        "words": [
          { "text": "Weingut", "confidence": 96.1, "bbox": { "x0": 10, "y0": 5, "x1": 80, "y1": 22 } }
        ]
      },
      "corrected": {
        "producer": "Weingut Keller",
        "name": "Riesling Trocken",
        "vintage": "2021"
      }
    }
  ]
}
```

`corrected` holds the string values the user actually submitted in the form (before
`parseVintage`). This is the ground truth.

An entry is only written when the user successfully submits the form — never on
cancel or validation error.

---

## Local storage

OCR training data is stored in IndexedDB under key `kellerverwaltung-ocr-training`.

---

## UI flow

1. User taps "Add photo" → camera opens
2. Photo selected → thumbnail shown + "Reading label…" spinner
3. OCR finishes → producer, name, vintage pre-filled (if text found); other fields
   unchanged. A subtle note: "Label read — review fields below."
4. If OCR fails or finds no useful text → silent fallback, fields stay empty
5. User reviews and adjusts all fields, then taps "Add Wine"
6. On submit: wine created, photo encoded and saved, OCR entry appended to local
   training data (keyed by the new wine ID, corrected values = submitted form values)

---

## New files

### `app/src/lib/ocr/tesseract.ts`

Thin wrapper around Tesseract.js. Lazy-loads the worker on first call.

```ts
export interface OcrWord {
  text: string
  confidence: number
  bbox: { x0: number; y0: number; x1: number; y1: number }
}

export interface OcrResult {
  text: string
  words: OcrWord[]
}

export async function runOcr(file: File): Promise<OcrResult>
```

Internally: `Tesseract.recognize(file, 'eng')` → maps `data.text` and `data.words`.

### `app/src/lib/data/ocr-store.ts`

Reads and writes OCR training data in IndexedDB.

```ts
export interface OcrEntry {
  wineId: string
  capturedAt: string
  ocr: OcrResult
  corrected: { producer: string; name: string; vintage: string }
}

export interface OcrTrainingData {
  version: 1
  entries: OcrEntry[]
}

export async function loadOcrData(): Promise<OcrTrainingData>
export async function appendOcrEntry(entry: OcrEntry): Promise<void>
```

`appendOcrEntry` loads existing data, pushes the new entry, saves back.

### `app/src/lib/data/ocr-store.test.ts`

- `loadOcrData` returns `{ version: 1, entries: [] }` when nothing stored
- `appendOcrEntry` persists an entry and it survives a reload
- Multiple appends accumulate without overwriting previous entries

---

## Modified files

### `app/package.json`

Add `tesseract.js` as a dependency.

### `app/src/routes/wine/new/+page.svelte`

- Add `let ocrRunning = $state(false)` and `let ocrNote = $state('')`
- In `handlePhotoSelect`: after setting `photoFile`, call `runOcr` in background
  (fire-and-forget from UI perspective); on result pre-fill `producer`, `name`,
  `vintage` if currently empty; set `ocrNote`; handle errors silently
- In `handleSubmit` (after wine is created and photo is saved): call
  `appendOcrEntry` with the wine ID, OCR result, and submitted field values —
  only if an OCR result exists for this session

### `app/src/lib/data/sync.ts`

**push:** after uploading photos and cellar.json, also upload
`data/ocr-training.json` (if local data has any entries).

**_pull:** after downloading cellar.json and photos, also download
`data/ocr-training.json` if it exists on GitHub and save it locally (remote
replaces local — single-device use, no conflict).

---

## Vite / PWA config

Tesseract.js WASM and worker scripts are large. Add them to the workbox
`globIgnores` (or rely on the existing `maximumFileSizeToCacheInBytes` setting)
so they are not precached — the browser's regular HTTP cache handles them.

Check whether `optimizeDeps.exclude: ['tesseract.js']` is needed in
`vite.config.ts` to prevent Vite from trying to bundle the WASM.

---

## Acceptance criteria

- [ ] After taking a photo, "Reading label…" appears within 1 s of selection
- [ ] Producer, name, and vintage fields are pre-filled when text is found
- [ ] Pre-fill does not overwrite a field the user has already typed into
- [ ] OCR failure is silent (no error shown, fields remain editable)
- [ ] After submitting, an OCR entry exists in IndexedDB with the correct wineId
      and corrected values matching what was submitted
- [ ] Push uploads `data/ocr-training.json` alongside cellar.json
- [ ] Pull downloads and stores `data/ocr-training.json` when present on GitHub
- [ ] `loadOcrData` and `appendOcrEntry` have unit tests
- [ ] `npm run lint`, `npm run check`, `npm test` pass
