# Plan: v0.6.0 — CSV Import

## Goal

Let the user import their existing bottle inventory from a CSV file. Preview the result before committing, flag validation errors per row, and handle duplicates (skip or overwrite).

---

## CSV format

Headers (case-insensitive, order-insensitive):

| Column     | Required | Notes                                         |
|------------|----------|-----------------------------------------------|
| `producer` | yes      |                                               |
| `name`     | yes      |                                               |
| `type`     | yes      | `red`, `white`, `sparkling`, `dessert`        |
| `vintage`  | yes      | integer year or literal `NV`                  |
| `bottles`  | yes      | integer ≥ 0                                   |
| `notes`    | no       | empty string if omitted                       |

- Delimiter: comma (`,`)
- First row must be a header row
- Extra columns are ignored
- Empty rows are skipped

### Validation rules per row

- `producer` and `name`: non-empty after trim
- `type`: one of the four allowed values (case-insensitive, normalized)
- `vintage`: integer 1800–2100 or the string `NV` (case-insensitive)
- `bottles`: integer ≥ 0

---

## Duplicate detection

A duplicate is a row whose (`producerKey`, `name` trimmed lowercase, `vintage`) matches an existing wine entry.

`producerKey` is derived with the existing `producerKey()` function.

The user chooses globally (not per-row) before confirming: **skip duplicates** (default) or **overwrite duplicates** (update `bottles` and `notes`; leave `id`, `photoRef`, `addedAt` unchanged).

---

## UI flow

1. Dashboard → new "Import CSV" button (beside the "+" add button)
2. → `/import` route: file picker (`<input type="file" accept=".csv">`)
3. After file selected, parse and validate client-side; show preview:
   - Summary line: "42 rows — 40 valid, 2 errors, 5 duplicates"
   - Error rows listed with row number and reason
   - Duplicate handling toggle: Skip / Overwrite
   - "Import N wines" confirm button (disabled if 0 valid rows after applying skip)
   - "Cancel" link back to dashboard
4. On confirm: write to store, navigate to dashboard

No server round-trip; everything is client-side.

---

## New files

### `app/src/lib/data/csv.ts`

Pure parsing and validation. No IndexedDB, no store.

```
parseCSV(text: string): ParsedRow[]

interface ParsedRow {
  rowNumber: number          // 1-based, excluding header
  raw: Record<string, string>
  valid: boolean
  error?: string             // human-readable reason if !valid
  entry?: ImportEntry        // populated if valid
}

interface ImportEntry {
  type: WineType
  producer: string
  name: string
  vintage: number | 'NV'
  bottles: number
  notes: string
  producerKey: string        // derived
}
```

### `app/src/lib/data/csv.test.ts`

Unit tests for `parseCSV`:
- Valid rows produce correct `ImportEntry` values
- Missing required column → all rows error with "Missing column: X"
- Extra columns are ignored
- Empty rows skipped
- Invalid type value → row error
- Invalid vintage (non-numeric, out-of-range, empty) → row error
- Negative bottles → row error
- `NV` vintage (case-insensitive) → `'NV'`
- Notes column absent → `notes: ''`
- Whitespace trimmed from all fields

### `app/src/routes/import/+page.svelte`

Import route. Svelte 5 runes (`$state`, `$derived`).

State:
- `file: File | null`
- `rows: ParsedRow[]`
- `duplicateMode: 'skip' | 'overwrite'`
- `importing: boolean`
- `done: boolean`

Derived:
- `validRows` — rows where `valid === true`
- `errorRows` — rows where `valid === false`
- `duplicateRows` — valid rows whose key matches an existing wine
- `toImport` — valid rows that will actually be written (depends on `duplicateMode`)

On confirm: call `importWines(toImport, duplicateMode)` in store.ts, then navigate to `/`.

### `app/src/routes/import/+page.ts`

```ts
export const prerender = false
```

---

## Store additions (`app/src/lib/data/store.ts`)

```ts
export async function importWines(
  rows: ImportEntry[],
  duplicateMode: 'skip' | 'overwrite'
): Promise<void>
```

Logic:
- For each row determine if it's a duplicate (same producerKey + name.toLowerCase().trim() + vintage)
- If skip: ignore duplicates
- If overwrite: update existing entry's `bottles` and `notes` via `updateWine()`
- Non-duplicates: create via `createWine()` (assigns uuid, addedAt, photoRef: '')
- Single `persist()` call at the end (not one per row) to avoid O(n) IndexedDB writes

`importWines` tests in `store.test.ts` (or a new `import.test.ts`):
- Valid rows imported as new wines
- Skip mode: duplicate not imported
- Overwrite mode: duplicate updates bottles+notes, preserves id/addedAt/photoRef
- Mixed: some new, some skip, some overwrite
- Empty rows array: no-op

---

## Dashboard change (`app/src/routes/+page.svelte`)

Add an "Import CSV" button in the header area (near the "+" button). Navigates to `/import`.

---

## Acceptance criteria

- [ ] Selecting a valid CSV with 300 rows parses and shows preview in < 1 s on iPhone
- [ ] Rows with invalid type, vintage, or bottles are flagged with row number and reason
- [ ] Missing required column (producer, name, type, vintage, bottles) flags all rows
- [ ] Duplicate detection works correctly (producer + name + vintage match)
- [ ] Skip mode: duplicates not imported, count shown in summary
- [ ] Overwrite mode: bottles and notes updated, id/photoRef/addedAt preserved
- [ ] Import button disabled when there are 0 rows to import
- [ ] After successful import, lands on dashboard with correct bottle total
- [ ] All `csv.ts` functions have unit tests
- [ ] `importWines` store function has unit tests
- [ ] `npm run lint`, `npm run check`, `npm test` pass
